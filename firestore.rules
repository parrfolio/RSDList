rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper: check if caller is admin
    function isAdmin() {
      return request.auth != null
        && exists(/databases/$(database)/documents/admins/$(request.auth.token.email));
    }

    // Helper: check if caller is the resource owner
    function isOwner(uid) {
      return request.auth != null && request.auth.uid == uid;
    }

    // Helper: check if the user has sharing enabled
    function isSharingEnabled(uid) {
      return get(/databases/$(database)/documents/users/$(uid)).data.sharingEnabled == true;
    }

    // Admins collection: only readable by the user checking their own email, writable by no one (admin SDK only)
    match /admins/{email} {
      allow read: if request.auth != null && request.auth.token.email == email;
      allow write: if false;
    }

    // Events: readable by all, writable only via Cloud Functions (admin SDK)
    match /events/{eventId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // Releases: readable by all, writable only via Cloud Functions (admin SDK)
    match /releases/{releaseId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // Users: readable/writable by owner only with field validation
    match /users/{uid} {
      allow read: if isOwner(uid);
      allow create: if isOwner(uid)
        && request.resource.data.keys().hasOnly(
          ['uid', 'displayName', 'email', 'photoURL', 'avatarId', 'authProviders', 'shareId', 'sharingEnabled', 'createdAt', 'updatedAt']
        )
        && request.resource.data.uid == uid;
      allow update: if isOwner(uid)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(
          ['displayName', 'photoURL', 'avatarId', 'shareId', 'sharingEnabled', 'updatedAt']
        );
      allow delete: if false;

      // Wants subcollection: readable/writable by owner, readable if sharing is enabled
      match /wants/{wantId} {
        allow read: if isOwner(uid) || isSharingEnabled(uid);
        allow create: if isOwner(uid)
          && request.resource.data.keys().hasOnly(
            ['wantId', 'eventId', 'releaseId', 'artist', 'title', 'imageUrl', 'format', 'releaseType', 'status', 'addedAt', 'acquiredAt', 'updatedAt']
          )
          && request.resource.data.status in ['WANTED', 'ACQUIRED'];
        allow update: if isOwner(uid)
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly(
            ['status', 'acquiredAt', 'updatedAt']
          )
          && request.resource.data.status in ['WANTED', 'ACQUIRED'];
        allow delete: if isOwner(uid);
      }
    }

    // Shares collection: publicly readable, owner-writable
    match /shares/{shareId} {
      allow read: if true;
      allow create: if request.auth != null
        && request.resource.data.uid == request.auth.uid
        && request.resource.data.keys().hasOnly(
          ['shareId', 'uid', 'ownerName', 'listName', 'createdAt', 'updatedAt']
        );
      allow update: if request.auth != null
        && resource.data.uid == request.auth.uid
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(
          ['ownerName', 'listName', 'updatedAt']
        );
      allow delete: if request.auth != null
        && resource.data.uid == request.auth.uid;
    }

    // Deny all other paths by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
